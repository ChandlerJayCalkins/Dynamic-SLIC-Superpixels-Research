/**
This Unit Test Suite was auto-generated
DO NOT EDIT THIS FILE MANUALLY
 */

#include <gtest/gtest.h>
#include <opencv2/opencv.hpp>
#include "preprocessing.hpp"

using namespace ltridp_slic_improved;

//=============================================================================
// Input Validation Tests
//=============================================================================

TEST(PreprocessingTest, EmptyImageShouldFail) {
    Preprocessor preprocessor;
    cv::Mat empty;
    cv::Mat output;
    
    EXPECT_FALSE(preprocessor.enhance(empty, output));
}

TEST(PreprocessingTest, WrongDepthShouldFail) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_32F, cv::Scalar(0.5));
    cv::Mat output;
    
    EXPECT_FALSE(preprocessor.enhance(input, output));
}

TEST(PreprocessingTest, NegativeGammaShouldFail) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    EXPECT_FALSE(preprocessor.enhance(input, output, -0.5));
}

TEST(PreprocessingTest, ZeroGammaShouldFail) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    EXPECT_FALSE(preprocessor.enhance(input, output, 0.0));
}

TEST(PreprocessingTest, NaNGammaShouldFail) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    EXPECT_FALSE(preprocessor.enhance(input, output, std::nan("")));
}

//=============================================================================
// Output Property Tests
//=============================================================================

TEST(PreprocessingTest, OutputHasCorrectDepth) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(input, output));
    EXPECT_EQ(output.depth(), CV_8U);
}

TEST(PreprocessingTest, OutputHasCorrectSize) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(input, output));
    EXPECT_EQ(output.size(), input.size());
}

TEST(PreprocessingTest, OutputHasCorrectType) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(input, output));
    EXPECT_EQ(output.type(), CV_8UC1);
}

TEST(PreprocessingTest, OutputValuesInValidRange) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(input, output));
    
    double minVal, maxVal;
    cv::minMaxLoc(output, &minVal, &maxVal);
    
    EXPECT_GE(minVal, 0.0);
    EXPECT_LE(maxVal, 255.0);
}

//=============================================================================
// Gamma Behavior Tests
//=============================================================================

TEST(PreprocessingTest, GammaBrighteningEffect) {
    Preprocessor preprocessor;
    cv::Mat dark(100, 100, CV_8UC1, cv::Scalar(64));
    cv::Mat brightened;
    
    ASSERT_TRUE(preprocessor.enhance(dark, brightened, 0.5));
    
    double meanOriginal = cv::mean(dark)[0];
    double meanBrightened = cv::mean(brightened)[0];
    
    EXPECT_GT(meanBrightened, meanOriginal);
}

TEST(PreprocessingTest, GammaDarkeningEffect) {
    Preprocessor preprocessor;
    cv::Mat bright(100, 100, CV_8UC1, cv::Scalar(192));
    cv::Mat darkened;
    
    ASSERT_TRUE(preprocessor.enhance(bright, darkened, 2.0));
    
    double meanOriginal = cv::mean(bright)[0];
    double meanDarkened = cv::mean(darkened)[0];
    
    EXPECT_LT(meanDarkened, meanOriginal);
}

TEST(PreprocessingTest, GammaIdentityTransform) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(input, output, 1.0));
    
    double meanOriginal = cv::mean(input)[0];
    double meanOutput = cv::mean(output)[0];
    
    // Should be very close (allowing for histogram reconstruction effects)
    EXPECT_NEAR(meanOutput, meanOriginal, 10.0);
}

TEST(PreprocessingTest, GammaPreservesBlack) {
    Preprocessor preprocessor;
    cv::Mat black(100, 100, CV_8UC1, cv::Scalar(0));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(black, output, 0.5));
    
    EXPECT_EQ(cv::mean(output)[0], 0.0);
}

TEST(PreprocessingTest, GammaPreservesWhite) {
    Preprocessor preprocessor;
    cv::Mat white(100, 100, CV_8UC1, cv::Scalar(255));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(white, output, 0.5));
    
    EXPECT_EQ(cv::mean(output)[0], 255.0);
}

TEST(PreprocessingTest, ExtremeGammaValues) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    // Very small gamma
    ASSERT_TRUE(preprocessor.enhance(input, output, 0.1));
    EXPECT_GT(cv::mean(output)[0], cv::mean(input)[0]);
    
    // Very large gamma
    ASSERT_TRUE(preprocessor.enhance(input, output, 5.0));
    EXPECT_LT(cv::mean(output)[0], cv::mean(input)[0]);
}

//=============================================================================
// Histogram Reconstruction Tests
//=============================================================================

TEST(PreprocessingTest, HistogramReducesNoise) {
    Preprocessor preprocessor;
    
    // Create image with salt-and-pepper noise
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::RNG rng(42);
    for (int i = 0; i < 1000; ++i) {
        int x = rng.uniform(0, 100);
        int y = rng.uniform(0, 100);
        input.at<uchar>(y, x) = rng.uniform(0, 2) * 255;
    }
    
    cv::Mat output;
    ASSERT_TRUE(preprocessor.enhance(input, output, 1.0));
    
    // Output should have lower std dev (less noisy)
    cv::Scalar meanInput, stdDevInput;
    cv::meanStdDev(input, meanInput, stdDevInput);
    
    cv::Scalar meanOutput, stdDevOutput;
    cv::meanStdDev(output, meanOutput, stdDevOutput);
    
    EXPECT_LT(stdDevOutput[0], stdDevInput[0]);
}

TEST(PreprocessingTest, HistogramPreservesStructure) {
    Preprocessor preprocessor;
    
    // Create image with gradient
    cv::Mat input(100, 100, CV_8UC1);
    for (int r = 0; r < 100; ++r) {
        for (int c = 0; c < 100; ++c) {
            input.at<uchar>(r, c) = static_cast<uchar>(r * 2.55);
        }
    }
    
    cv::Mat output;
    ASSERT_TRUE(preprocessor.enhance(input, output, 1.0));
    
    // Should still have gradient structure (increasing values)
    EXPECT_LT(cv::mean(output(cv::Rect(0, 0, 100, 33)))[0],
              cv::mean(output(cv::Rect(0, 67, 100, 33)))[0]);
}

TEST(PreprocessingTest, UniformImageStaysUniform) {
    Preprocessor preprocessor;
    cv::Mat uniform(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(uniform, output, 1.0));
    
    cv::Scalar mean, stdDev;
    cv::meanStdDev(output, mean, stdDev);
    
    // Should remain very uniform
    EXPECT_LT(stdDev[0], 5.0);
}

TEST(PreprocessingTest, GradientImagePreservesGradient) {
    Preprocessor preprocessor;
    
    cv::Mat gradient(100, 100, CV_8UC1);
    for (int c = 0; c < 100; ++c) {
        for (int r = 0; r < 100; ++r) {
            gradient.at<uchar>(r, c) = static_cast<uchar>(c * 2.55);
        }
    }
    
    cv::Mat output;
    ASSERT_TRUE(preprocessor.enhance(gradient, output, 1.0));
    
    // Left side should be darker than right side
    double leftMean = cv::mean(output(cv::Rect(0, 0, 33, 100)))[0];
    double rightMean = cv::mean(output(cv::Rect(67, 0, 33, 100)))[0];
    
    EXPECT_LT(leftMean, rightMean);
}

//=============================================================================
// Edge Case Tests
//=============================================================================

TEST(PreprocessingTest, TinyImage) {
    Preprocessor preprocessor;
    cv::Mat tiny(2, 2, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(tiny, output));
    EXPECT_EQ(output.size(), tiny.size());
}

TEST(PreprocessingTest, LargeImage) {
    Preprocessor preprocessor;
    cv::Mat large(1000, 1000, CV_8UC1, cv::Scalar(128));
    cv::Mat output;
    
    ASSERT_TRUE(preprocessor.enhance(large, output));
    EXPECT_EQ(output.size(), large.size());
}

//=============================================================================
// Integration Tests
//=============================================================================

TEST(PreprocessingTest, DeterministicOutput) {
    Preprocessor preprocessor;
    cv::Mat input(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat output1, output2;
    
    ASSERT_TRUE(preprocessor.enhance(input, output1, 0.8));
    ASSERT_TRUE(preprocessor.enhance(input, output2, 0.8));
    
    // Should produce identical results
    cv::Mat diff;
    cv::absdiff(output1, output2, diff);
    EXPECT_EQ(cv::countNonZero(diff), 0);
}

TEST(PreprocessingTest, EndToEndPipeline) {
    Preprocessor preprocessor;
    
    // Create realistic test image
    cv::Mat input(256, 256, CV_8UC1);
    for (int r = 0; r < 256; ++r) {
        for (int c = 0; c < 256; ++c) {
            input.at<uchar>(r, c) = static_cast<uchar>(
                128 + 50 * std::sin(r * 0.1) * std::cos(c * 0.1)
            );
        }
    }
    
    cv::Mat output;
    ASSERT_TRUE(preprocessor.enhance(input, output, 0.5));
    
    // Verify output properties
    EXPECT_EQ(output.type(), CV_8UC1);
    EXPECT_EQ(output.size(), input.size());
    EXPECT_FALSE(output.empty());
    
    double minVal, maxVal;
    cv::minMaxLoc(output, &minVal, &maxVal);
    EXPECT_GE(minVal, 0.0);
    EXPECT_LE(maxVal, 255.0);
}

//=============================================================================
// Main
//=============================================================================

int main(int argc, char** argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
